.386
F EQU 1
WRITELV MACRO CHR;PRINT PROFIT LEVEL
	LEA DX, CRLF
	MOV AH,9
	INT 21H
	MOV DL, CHR
	MOV AH, 2
	INT 21H
	LEA DX, CRLF
	MOV AH, 9
	INT 21H
ENDM WRITELV
STACK SEGMENT USE16 STACK
	DB 200 DUP(0)
STACK ENDS

DATA SEGMENT USE16 PUBLIC 'DATA'
	BNAME DB 'NING JIA',0DH,0	;BOSS NAME,0DH TO MATCH LF
	BPASS DB 'SECRET',0DH		;PASSWORD
	N EQU 30
	S1 DB 'SHOP1' ,0		;END WITH ZERO
	GA1 DB 'PEN', 7 DUP(0)	;GOODS NAME
		DW 35, 56, 70, 25, ?;PROFIT MARGIN IS REMAINED HERE
		;PURCHASE PRICE:35		SELLING PRICE:56
		;PURCHASE NUM:70		SELL NUM:25
		;PROFIT = (SP * SN - PP * PN) * 100 / (PP * PN)
	GA2 DB 'BOOK', 6 DUP(0)
		DW 12, 30, 25, 5, ?
	GA3 DB 'CIGARETTE', 0
		DW 30, 100, 50, 40, ?
	GA4 DB 'CLOUTHES', 2 DUP(0)
		DW 200, 580, 20, 18, ?
	GA5 DB 'NECKLACE', 2 DUP(0)
		DW 500, 1900, 5, 4, ?
	GAN DB N-5 DUP ('TEMP-VALUE', 15, 0, 20, 0, 30, 0, 2, 0, ?, ?)
	S2 DB 'SHOP2', 0
	DIF DW $-GA1
	GB1 DB 'PEN', 7 DUP(0)
		DW 35, 50, 30, 25, ?
	GB2 DB 'BOOK', 6 DUP(0)
		DW 12, 28, 20, 15, ?
	GB3 DB 'CIGARETTE', 0, ?
		DW 30, 90, 45, 40, ?
	GB4 DB 'CLOUTHES', 2 DUP(0)
		DW 200, 550, 20, 15, ?
	GB5 DB 'NECKLACE', 2 DUP(0)
		DW 500, 2000, 8, 5, ?
	GBN DB N-5 DUP ('TEMP-VALUE', 15, 0, 18, 0, 50, 0, 40, 0, ?, ?)

	HINT1 DB 0DH, 0AH, 'PLEASE ENTER YOUR NAME:', 0DH, 0AH, '$'
	HINT2 DB 0DH, 0AH, 'PLEASE ENTER YOUR PASSWORD:', 0DH, 0AH, '$'
	HINT3 DB 0DH, 0AH, 'FAIL TO LOG IN!', 0DH, 0AH, '$'
	HINT4 DB 0DH, 0AH, 'PLEASE ENTER THE GOODS YOU WANT', 0DH, 0AH, '$'
	CRLF DB 0DH, 0AH, '$'
	BUF1 DB 10,?	;10 IS THE LENGTH OF NAME
	IN_NAME DB 10 DUP(0)
	BUF2 DB 7,?	;6 IS THE LENGTH OF PASSWORD
	IN_PWD DB 6 DUP(0)
	BUF3 DB 10,?
	GN DB 10 DUP(0)
	AUTH DB 0



	HINTE DB "Please input the number you want, use 'enter' to skip", '$'
	PPE DB "Purchase Price:",'$'
	SPE DB "Selling Price:", '$'
	TSE DB "Total Stock:", '$'
	SEP DB ">> ", '$'
	BUF1E DB 6, ?, 6 DUP(0)
	TEMP DW 0

DATA ENDS

CODE SEGMENT USE16
	ASSUME CS:CODE, DS:DATA, SS:STACK
START:
	MOV AX, DATA
	MOV DS, AX
I_NAME:;NAME is a keyword in asm(Pseudo instruction)
	;PRINT HINT1
	LEA DX, HINT1
	MOV AH, 9
	INT 21H	
	;INPUT NAME
	MOV CX, 10
	LEA EDX, IN_NAME
L1:
	MOV BYTE PTR [EDX], 0;r16 must be index or base register, so change the EX to EDX
	INC EDX
	LOOP L1
	LEA DX, BUF1
	MOV AH, 0AH
	INT 21H
	CMP IN_NAME, 0DH
	JE BEFORE
	CMP IN_NAME, 'q'
	JNE JNAME
	CMP IN_NAME + 1, 0DH
	JE EXIT
;MATCH THE NAME
JNAME:
	LEA BX, BNAME
	LEA SI, IN_NAME
	MOV CX, 10
LOPA:
	MOV AL, [BX]
	CMP AL, [SI]
	JNE ERROR
	INC BX
	INC SI
	LOOP LOPA

I_PWD:
	;PRINT HINT2
	LEA DX, HINT2
	MOV AH,9
	INT 21H	
	;INPUT PASSWORD
	MOV CX, 7
	LEA EDX, IN_PWD
L2:
	MOV BYTE PTR [EDX], 0
	INC EDX
	LOOP L2
	LEA DX, BUF2
	MOV AH, 0AH
	INT 21H
;MATCH THE PASSWORD
JPASS:
	LEA BX, BPASS
	LEA SI, IN_PWD
	MOV CX, 7
LP:
	MOV AL, [BX]
	CMP AL, [SI]
	JNE ERROR
	INC BX
	INC SI
	LOOP LP
	MOV AUTH, 1
	JMP GOODS
ERROR:
	LEA DX, HINT3
	MOV AH, 9
	INT 21H
	JMP I_NAME
BEFORE:
	MOV AUTH, 0
GOODS:
	LEA DX, HINT4
	MOV AH, 9
	INT 21H;PRINT HINT
	MOV CX, 10
	LEA EDX, GN
L3:
	MOV BYTE PTR [EDX], 0
	INC EDX
	LOOP L3
	LEA DX, BUF3
	MOV AH, 0AH
	INT 21H;INPUT GOODS NAME
	CMP GN, 0DH
	JE I_NAME;JUMP WHEN INPUT ONLY ENTER
	MOV CX, N
	LEA BX, GA1;USE BX TO STORE THE OFFSET OF GOODS NAME
MATCH:
	PUSH CX
	MOV CL, BUF3+1
	MOV CH, 0
	MOV AH, CL
	LEA SI, GN	
	MOV DI, BX
LOOPA:
	MOV AL, [SI];MOV INPUT GOODS NAME
	CMP AL, [DI]
	JNE CONTINUE
	INC SI
	INC DI
	LOOP LOOPA
	CMP AH, 10
	JE TRUE
	CMP BYTE PTR [DI], 0
	JE TRUE
CONTINUE:
	POP CX
	ADD BX, 20
	LOOP MATCH
	JMP GOODS;FAIL TO MATCH RESTART
TRUE:
	CMP AUTH, 1
	JE SUC
	;IF AUTH = 0 THEN PRINT GOODS AGAIN
	LEA DX, CRLF
	MOV AH, 9
	INT 21H
	MOV AL, [SI-1]
	MOV BYTE PTR [SI-1], '$';must indicate the type of oprand
	LEA DX, GN
	MOV AH, 9
	INT 21H
	MOV DL, AL
	MOV AH, 2
	INT 21H
	JMP I_NAME
SUC:
	CALL PROFIT
	PUSH EAX
	ADD BX, DIF
	ADD BX, 2
	CALL PROFIT
	POP ECX
	ADD EAX, ECX
	SAR EAX, 1;(EAX) = APR
IF F
	PUSH OFFSET GA1
	CALL MODIFY
ENDIF
	CMP EAX, 90
	JNGE NA 
	PUSH EAX
	WRITELV 'A'
	POP EAX
	CALL BASE
	JMP I_NAME
NA:
	CMP EAX, 50
	JNGE NB
	PUSH EAX
	WRITELV 'B'
	POP EAX
	CALL BASE
	JMP I_NAME
NB:
	CMP EAX, 20
	JNGE NC
	PUSH EAX
	WRITELV 'C'
	POP EAX
	CALL BASE
	JMP I_NAME
NC:
	CMP EAX, 0
	JNGE ND
	PUSH EAX
	WRITELV 'D'
	POP EAX
	CALL BASE
	JMP I_NAME
ND:
	PUSH EAX
	WRITELV 'F'
	POP EAX
	CALL BASE
	JMP I_NAME

BASE PROC;(EAX) IS THE NUM CONVERGING TO THE 10-BASE AND PRINT
	MOV ESI, 10
	MOV CX, 0
	CMP EAX, 0
	JGE POS
	PUSH EAX
	MOV DL, '-'
	MOV AH, 2
	INT 21H
	POP EAX
	NEG EAX;CX TO RECORD THE STEP COUNT
POS:
	MOV EDX, 0
	DIV ESI
	ADD EDX, '0'
	PUSH EDX
	INC CX
	CMP EAX, 0
	JNE POS
PRC:
	POP EDX
	MOV AH, 2
	INT 21H
	LOOP PRC
	MOV DL, '%'
	MOV AH, 2
	INT 21H
	RET
BASE ENDP
PROFIT PROC ;(BX) IS THE GOODS OFFSET
	MOV AX, 10[BX];PP
	MUL WORD PTR 14[BX]
	SHL EDX, 16
	MOV DX, AX
	MOV ECX, EDX;(ECX) = PP * PN
	MOV AX, 12[BX];SP
	MUL WORD PTR 16[BX]
	SHL EDX, 16
	MOV DX, AX
	MOV EAX, EDX;(EAX) = SP * SN
	SUB EAX, ECX
	MOV ESI, 100
	IMUL ESI
	IDIV ECX;ASSUME THE ABS OF THE RESULT NOT EXCEEDING 2^31
	RET
PROFIT ENDP



PRINTS MACRO ADR;MODIFY AX,DX
	LEA DX, ADR
	MOV AH, 9
	INT 21H
ENDM

WRITE MACRO ADR
	LEA DX, ADR
	MOV AH, 10
	INT 21H
ENDM

PRINTB10 PROC;(AX) IS THE NUM CONVERGING TO THE 10-BASE AND PRINT
	MOV CX, 0
L1E:
	MOV BX, 10
	MOV DX, 0
	DIV BX
	ADD DX, '0'
	PUSH DX
	INC CX
	CMP AX, 0
	JNE L1E
PRCE:
	POP DX
	MOV AH, 2
	INT 21H
	LOOP PRCE
	RET
PRINTB10 ENDP


	
STR_TO_B10 PROC
	MOV CL, BUF1E + 1
	MOV CH, 0
	LEA BX, BUF1E + 2
	MOV TEMP, 0
	MOV AX, TEMP
L5:;TEMP = TEMP * 10 + [BX]
	MOV DI, 10
	MUL DI
	MOV DL, [BX]
	SUB DL, '0'
	MOV DH, 0
	ADD AX, DX
	INC BX
	LOOP L5
	MOV TEMP, AX
	RET
STR_TO_B10 ENDP

MODIFY PROC;ASSUME THE ORD IS ———— IP,OFFSET OF GOODS 
	PUSH AX
	PUSH SI
	PUSH CX
	PUSH DX
	PUSH BX
	PUSH BP
	PUSH DI
	;TO PROTECT THE REG
	MOV BP, SP
	MOV SI, 16[BP];SI IS THE OFFSET OF GOODS
	PRINTS HINTE
PPH:
	PRINTS CRLF
	PRINTS PPE
	MOV AX, 10[SI]
	CALL PRINTB10
	PRINTS SEP
	WRITE BUF1E
	CMP 1[BUF1E], 0
	JE NEXT1 
	MOV CL, BUF1E + 1
	MOV CH, 0
	MOV DI, OFFSET BUF1E + 2
L6:
	CMP BYTE PTR [DI], '0'
	JB PPH
	CMP BYTE PTR [DI], '9'
	JA PPH
	INC DI
	LOOP L6
	CALL STR_TO_B10
	MOV AX, TEMP
	MOV 10[SI], AX
NEXT1:

	PRINTS CRLF
	PRINTS SPE
	MOV AX, 12[SI]
	CALL PRINTB10
	PRINTS SEP
	WRITE BUF1E
	CMP 1[BUF1E], 0
	JE NEXT2
	MOV CL, BUF1E + 1
	MOV CH, 0
	MOV DI, OFFSET BUF1E + 2
L7:
	CMP BYTE PTR [DI], '0'
	JB NEXT1
	CMP BYTE PTR [DI], '9'
	JA NEXT1
	INC DI
	LOOP L7
	CALL STR_TO_B10
	MOV AX, TEMP
	MOV 12[SI], AX
NEXT2:

	PRINTS CRLF
	PRINTS TSE
	MOV AX, 14[SI]
	CALL PRINTB10
	PRINTS SEP
	WRITE BUF1E
	CMP 1[BUF1E], 0
	JE NEXT3
	MOV CL, BUF1E + 1
	MOV CH, 0
	MOV DI, OFFSET BUF1E + 2
L8:
	CMP BYTE PTR [DI], '0'
	JB NEXT2
	CMP BYTE PTR[DI], '9'
	JA NEXT2
	INC DI
	LOOP L8
	CALL STR_TO_B10
	MOV AX, TEMP
	MOV 14[SI], AX
NEXT3:
	POP DI
	POP BP
	POP BX
	POP DX
	POP CX
	POP SI
	POP AX
	RET 2
MODIFY ENDP
;FINISHED THE MODIFY MODULE

RANK PROC;IP
	PUSH AX
	PUSH BX
	PUSH CX
	PUSH DI
	PUSH SI
	MOV CX, N
	LEA SI, GA1 + 18
L9:
	MOV AX, 1;RANK
	PUSH CX
	MOV CX, N
	LEA DI, GA1 + 18
L10:
	MOV BX, [DI]
	CMP BX, [SI]
	JNG NGREAT
	INC AX
NGREAT: 
	ADD DI, 20
	LOOP L10
	POP CX
	ADD SI, 20
	MOV [SI+GB1-GA1], AX
	LOOP L9
	POP SI
	POP DI
	POP CX
	POP BX
	POP AX
	RET
RANK ENDP


EXIT:
	MOV AH, 4CH
	INT 21H
CODE ENDS
END START